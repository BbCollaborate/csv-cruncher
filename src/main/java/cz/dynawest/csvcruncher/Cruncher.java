package cz.dynawest.csvcruncher;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.LineIterator;
import org.apache.commons.lang3.StringUtils;

public class Cruncher
{
    private static final Logger log = Logger.getLogger(App.class.getName());

    public static final String TABLE_NAME__OUTPUT = "output";
    public static final long TIMESTAMP_SUBSTRACT = 1_530_000_000_000L; // To make the unique ID a smaller number.

    private Connection conn;
    private Cruncher.Options options;

    public Cruncher(Cruncher.Options options) throws ClassNotFoundException, SQLException
    {
        this.options = options;
        this.init();
    }

    private void init() throws ClassNotFoundException, SQLException
    {
        System.setProperty("textdb.allow_full_path", "true");
        Class.forName("org.hsqldb.jdbc.JDBCDriver");
        String dbPath = StringUtils.defaultIfEmpty(this.options.dbPath, "hsqldb") + "/cruncher";
        this.conn = DriverManager.getConnection("jdbc:hsqldb:file:" + dbPath + ";shutdown=true", "SA", "");
    }

    /**
     * Performs the whole process.
     */
    public void crunch() throws Exception
    {
        validateParameters();

        Map<String, File> tablesToFiles = new HashMap<>();
        try
        {
            boolean addCounterColumn = true;    // TODO: Get this from the parameters.
            boolean convertResultToJson = true; // TODO: Get this from the parameters.

            byte reachedStage = 0;
            boolean crunchSuccess = false;

            File outFile = this.getFileObject(this.options.csvPathOut);
            outFile.getAbsoluteFile().getParentFile().mkdirs();

            try
            {
                // For each input CSV file...
                for (String path : this.options.csvPathIn) {
                    File csvInFile = this.getFileObject(path);
                    log.info(" * CSV input: " + csvInFile);

                    String tableName = normalizeFileNameForTableName(csvInFile);
                    File previousIfAny = tablesToFiles.put(tableName, csvInFile);
                    if (previousIfAny != null)
                        throw new IllegalArgumentException("File names normalized to table names collide: " + previousIfAny + ", " + csvInFile);

                    String[] colNames = parseColsFromFirstLine(csvInFile);
                    // Read the CSV into a table.
                    this.createTableForCsvFile(tableName, csvInFile, colNames, true);
                }


                // Should the result have a unique incremental ID as an added 1st column?
                String counterColumnDdl = "";
                String counterColumnVal = "";

                if (addCounterColumn) {

                    // A timestamp at the beginning:
                    //sql = "DECLARE crunchCounter BIGINT DEFAULT UNIX_MILLIS() - 1530000000000"; // Uh oh. Variables can't be used in SELECTs.
                    //executeDbCommand(sql, "Failed creating the counter variable: ");
                    long timeStamp = (System.currentTimeMillis() - TIMESTAMP_SUBSTRACT);

                    String sql;

                    // Using an IDENTITY column which has an unnamed sequence?
                    //counterColumnDdl = "crunchCounter BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY";
                    // ALTER TABLE output ALTER COLUMN crunchCounter RESTART WITH UNIX_MILLIS() - 1530000000000;
                    // INSERT INTO otherTable VALUES (IDENTITY(), ...)

                    // Or using a sequence?
                    sql = "CREATE SEQUENCE IF NOT EXISTS crunchCounter AS BIGINT NO CYCLE"; // MINVALUE 1 STARTS WITH <number>
                    executeDbCommand(sql, "Failed creating the counter sequence: ");

                    sql = "ALTER SEQUENCE crunchCounter RESTART WITH " + timeStamp; //
                    executeDbCommand(sql, "Failed altering the counter sequence: ");

                    // ... referencing it explicitely?
                    //counterColumnDdl = "crunchCounter BIGINT PRIMARY KEY, ";
                    // INSERT INTO output VALUES (NEXT VALUE FOR crunchCounter, ...)
                    //counterColumnVal = "NEXT VALUE FOR crunchCounter, ";

                    // ... or using it through GENERATED BY?
                    counterColumnDdl = "crunchCounter BIGINT GENERATED BY DEFAULT AS SEQUENCE crunchCounter PRIMARY KEY, ";
                    //counterColumnVal = "DEFAULT, ";
                    counterColumnVal = "NULL, ";
                    // INSERT INTO output (id, firstname, lastname) VALUES (DEFAULT, ...)
                    // INSERT INTO otherTable VALUES (CURRENT VALUE FOR crunchCounter, ...)
                }


                // Perform the SQL
                PreparedStatement statement = this.conn.prepareStatement(this.options.sql);
                ResultSet rs = statement.executeQuery();

                // Column names
                String [] colNames = new String[rs.getMetaData().getColumnCount()];
                for (int col = 0; col < colNames.length; col++) {
                    colNames[col] = rs.getMetaData().getColumnName(col + 1);
                }

                // Write the result into a CSV
                this.createTableForCsvFile(TABLE_NAME__OUTPUT, outFile, colNames, true, counterColumnDdl);
                reachedStage = 2;

                // The provided SQL could be something like "SELECT @counter, foo, bar FROM ..."
                //String selectSql = this.options.sql.replace("@counter", counterColumnVal);
                // On the other hand, that's too much space for the user to screw up. Let's force it:
                String selectSql = this.options.sql.replace("SELECT ", "SELECT " + counterColumnVal + " ");

                String userSql = "INSERT INTO output (" + selectSql + ")";
                log.info("User's SQL: " + userSql);
                statement = this.conn.prepareStatement(userSql);
                int rowsAffected = statement.executeUpdate();
                crunchSuccess = true;


                // Now let's convert it to JSON if necessary.
                reachedStage = 3;
            }
            finally
            {
                if (crunchSuccess)
                {
                    for (Map.Entry<String, File> tableAndFile: tablesToFiles.entrySet()) {
                        //if (reachedStage >= 1)
                        this.detachTable(tableAndFile.getKey(), false);
                    }

                    if (reachedStage >= 2)
                        this.detachTable("output", false);

                    PreparedStatement ps = this.conn.prepareStatement("DROP SCHEMA PUBLIC CASCADE");
                    ps.execute();
                    this.conn.close();
                }
            }
        }
        catch (Exception ex)
        {
            throw ex;
        }
    }

    private void executeDbCommand(String sql, String errorMsg) throws SQLException
    {
        try {
            this.conn.createStatement().execute(sql);
        } catch (Exception ex) {
            throw new RuntimeException(errorMsg + sql + "\n" + this.conn.getWarnings().getNextWarning());
        }
    }

    private String normalizeFileNameForTableName(File fileName)
    {
        return fileName.getName().replaceFirst(".csv$", "").replaceAll("[^a-zA-Z0-9_]", "_");
    }

    private void validateParameters() throws FileNotFoundException
    {
        if (this.options.csvPathIn == null || this.options.csvPathIn.isEmpty())
            throw new IllegalArgumentException(" -in is not set.");

        if (this.options.sql == null)
            throw new IllegalArgumentException(" -sql is not set.");

        if (this.options.csvPathOut == null)
            throw new IllegalArgumentException(" -out is not set.");


        for (String path : this.options.csvPathIn) {
            File ex = new File(path);
            if (!ex.exists())
                throw new FileNotFoundException("CSV file not found: " + ex.getPath());
        }
    }

    private static String[] parseColsFromFirstLine(File file) throws IOException
    {
        Pattern pat = Pattern.compile("[a-z][a-z0-9]*", 2);
        Matcher mat = pat.matcher("");
        ArrayList cols = new ArrayList();
        LineIterator lineIterator = FileUtils.lineIterator(file);
        if (!lineIterator.hasNext())
        {
            throw new IllegalStateException("No first line with columns definition (format: [# ] <colName> [, ...]) in: " + file.getPath());
        }
        else
        {
            String line = lineIterator.nextLine();
            line = StringUtils.stripStart(line, "#");
            String[] colNames = StringUtils.splitPreserveAllTokens(line, ",;");

            for (int i = 0; i < colNames.length; ++i)
            {
                String colName = colNames[i];
                colName = colName.trim();
                if (0 == colName.length())
                    throw new IllegalStateException("Empty column name (separators: ,; ) in: " + file.getPath());

                if (!mat.reset(colName).matches())
                    throw new IllegalStateException("Colname must be valid SQL identifier, i.e. must match /[a-z][a-z0-9]*/i in: " + file.getPath());

                cols.add(colName);
            }

            return (String[]) ((String[]) cols.toArray(new String[cols.size()]));
        }
    }

    private void createTableForCsvFile(String tableName, File csvFileToBind, String[] colNames, boolean ignoreFirst) throws SQLException, FileNotFoundException
    {
        createTableForCsvFile(tableName, csvFileToBind, colNames, ignoreFirst, "");
    }


    private void createTableForCsvFile(String tableName, File csvFileToBind, String[] colNames, boolean ignoreFirst, String counterColumnDdl) throws SQLException, FileNotFoundException
    {
        boolean readOnly = false;
        StringBuilder sbCsvHeader = new StringBuilder("# ");
        StringBuilder sb = (new StringBuilder("CREATE TEXT TABLE ")).append(tableName).append(" ( ");

        // The counter column, if any.
        sb.append(counterColumnDdl);

        int colCount = colNames.length;

        // Columns
        String colName;
        for (int colIndex = 0; colIndex < colCount; ++colIndex)
        {
            colName = colNames[colIndex];
            sbCsvHeader.append(colName).append(", ");
            colName = escapeSql(colName);
            sb.append(colName).append(" VARCHAR(255), ");
        }
        sbCsvHeader.delete(sbCsvHeader.length() - 2, sbCsvHeader.length());
        sb.delete(sb.length() - 2, sb.length());
        sb.append(" )");
        log.info("Output table DDL SQL: " + sb.toString());

        PreparedStatement statement = this.conn.prepareStatement(sb.toString());
        boolean success = statement.execute();

        // Bind the table to the CSV file.
        String csvPath = csvFileToBind.getPath();
        csvPath = escapeSql(csvPath);
        String ignoreFirstFlag = ignoreFirst ? "ignore_first=true;" : "";
        String DESC = readOnly ? "DESC" : "";
        statement = this.conn.prepareStatement("SET TABLE " + tableName + " SOURCE \'" + csvPath + ";" + ignoreFirstFlag + "fs=,\' " + DESC);
        success = statement.execute();
    }

    private void detachTable(String name, boolean reattach) throws SQLException
    {
        String sql = "SET TABLE " + escapeSql(name) + " SOURCE " + (reattach ? "ON" : "OFF");
        PreparedStatement ps = this.conn.prepareStatement(sql);
        boolean succ = ps.execute();
    }

    private void testDumpSelect(String tableName) throws SQLException
    {
        PreparedStatement ps = this.conn.prepareStatement("SELECT * FROM " + tableName);
        ResultSet rs = ps.executeQuery();
        ResultSetMetaData metaData = rs.getMetaData();

        while (rs.next())
        {
            System.out.println(" ------- ");

            for (int i = 1; i <= metaData.getColumnCount(); ++i)
            {
                System.out.println(" " + metaData.getColumnLabel(i) + ": " + rs.getObject(i));
            }
        }

    }

    private File getFileObject(String path)
    {
        return Paths.get(path).isAbsolute() ? new File(path) : new File(System.getProperty("user.dir"), path);
    }

    private String escapeSql(String str)
    {
        return str.replace("'", "''");
    }

    protected static class Options
    {
        protected List<String> csvPathIn = new ArrayList<>();
        protected String sql;
        protected String csvPathOut;
        protected String dbPath = null;

        public boolean isFilled()
        {
            return this.csvPathIn != null && this.csvPathOut != null && this.sql != null;
        }

        public String toString()
        {
            return "\n    dbPath: " + this.dbPath + "\n    csvPathIn: " + this.csvPathIn + "\n    csvPathOut: " + this.csvPathOut + "\n    sql: " + this.sql;
        }
    }
}
